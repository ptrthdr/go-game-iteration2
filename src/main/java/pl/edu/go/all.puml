@startuml
skinparam classAttributeIconSize 0
skinparam dpi 160
title Diagram klas - Go-Game (Iteracja 2) - serwer + logika + GUI + scoring/review

' =======================
'  pl.edu.go.board
' =======================
package "pl.edu.go.board" as board {

  enum Territory {
    BLACK
    WHITE
    SEKI
    NEUTRAL
  }

  class Board {
    + {static} int EMPTY
    + {static} int BLACK
    + {static} int WHITE

    - int size
    - int[][] board

    + Board(int size)
    + boolean playMove(int color, int x, int y)
    + int[][] getState()
    + String toString()

    - java.util.List<int[]> neighbors(int x, int y)
    - pl.edu.go.model.StoneGroup getGroup(int x, int y)
    - int countLiberties(pl.edu.go.model.StoneGroup group)
    - void removeGroup(pl.edu.go.model.StoneGroup group)
  }

  class BoardFactory <<Factory Method>> {
    + {static} Board createBoard(int size)
  }
}

' =======================
'  pl.edu.go.model
' =======================
package "pl.edu.go.model" as model {

  class Stone {
    - int x
    - int y
    - int color
    + Stone(int x, int y, int color)
    + int getX()
    + int getY()
    + int getColor()
  }

  class StoneGroup {
    - int color
    - java.util.Set<Stone> stones
    + StoneGroup(int color)
    + void addStone(Stone s)
    + java.util.Set<Stone> getStones()
    + int getColor()
  }
}

' =======================
'  pl.edu.go.move
' =======================
package "pl.edu.go.move" as move {

  class Move {
    - int color
    - int x
    - int y
    + Move(int color, int x, int y)
    + int getColor()
    + int getX()
    + int getY()
  }

  class MoveFactory <<Factory Method>> {
    + {static} Move createMove(int color, int x, int y)
  }

  class MoveAdapter <<Adapter>> {
    + {static} int[] toInternal(String move)
    + {static} String toExternal(int x, int y)
  }
}

' =======================
'  pl.edu.go.analysis
' =======================
package "pl.edu.go.analysis" as analysis {

  class PositionAnalyzer {
    - pl.edu.go.board.Board board
    + PositionAnalyzer(pl.edu.go.board.Board board)
    + java.util.List<pl.edu.go.model.StoneGroup> getDeadGroups()
  }

  class TerritoryAnalyzer {
    - pl.edu.go.board.Board board
    + TerritoryAnalyzer(pl.edu.go.board.Board board)
    + pl.edu.go.board.Territory[][] computeTerritory()
  }

  class ScoreCalculator {
    + {static} int[] computeScore(pl.edu.go.board.Board board)
  }
}

' =======================
'  pl.edu.go.game
' =======================
package "pl.edu.go.game" as game {

  interface ObservableGame <<Subject (Observer)>> {
    + void addObserver(GameObserver observer)
    + void removeObserver(GameObserver observer)
  }

  interface GameObserver <<Observer>> {
    + void onBoardChanged(pl.edu.go.board.Board board)
    + void onPlayerToMoveChanged(PlayerColor player)
    + void onGameEnded(GameResult result)
    ' (Jeśli masz onPhaseChanged w kodzie, dopisz tu tę linijkę:)
    ' + void onPhaseChanged(GamePhase phase)
  }

  enum GamePhase {
    PLAYING
    SCORING_REVIEW
    FINISHED
  }

  enum PlayerColor {
    BLACK
    WHITE
    --
    - int boardColor
    + int toBoardColor()
    + PlayerColor opposite()
    + {static} PlayerColor fromBoardColor(int boardColor)
  }

  class GameResult {
    - PlayerColor winner
    - String reason
    + GameResult(PlayerColor winner, String reason)
    + PlayerColor getWinner()
    + String getReason()
  }

  class Game implements ObservableGame {
    - pl.edu.go.board.Board board
    - PlayerColor currentPlayer
    - boolean finished
    - GameResult result
    - int consecutivePasses
    - java.util.List<GameObserver> observers
    - GamePhase phase

    + Game(pl.edu.go.board.Board board)
    + pl.edu.go.board.Board getBoard()
    + PlayerColor getCurrentPlayer()
    + boolean isFinished()
    ' getResult() jest opcjonalny (u Ciebie bywa usunięty); zostaw jako komentarz:
    ' + GameResult getResult()
    + GamePhase getPhase()

    + void addObserver(GameObserver observer)
    + void removeObserver(GameObserver observer)

    + void playMove(PlayerColor player, int x, int y)
    + void playMove(pl.edu.go.move.Move move)
    + void pass(PlayerColor player)
    + void resign(PlayerColor player)
    + void agree(PlayerColor player)
    + void resume(PlayerColor player)

    - void notifyBoardChanged()
    - void notifyPlayerToMoveChanged()
    - void notifyGameEnded()
    - void notifyPhaseChanged()
  }
}

' =======================
'  pl.edu.go.command
' =======================
package "pl.edu.go.command" as command {

  interface GameCommand <<Command>> {
    + void execute(pl.edu.go.game.Game game)
  }

  class PlaceStoneCommand <<Command>> {
    - int x
    - int y
    - pl.edu.go.game.PlayerColor player
    + PlaceStoneCommand(int x, int y, pl.edu.go.game.PlayerColor player)
    + void execute(pl.edu.go.game.Game game)
  }

  class PassCommand <<Command>> {
    - pl.edu.go.game.PlayerColor player
    + PassCommand(pl.edu.go.game.PlayerColor player)
    + void execute(pl.edu.go.game.Game game)
  }

  class ResignCommand <<Command>> {
    - pl.edu.go.game.PlayerColor player
    + ResignCommand(pl.edu.go.game.PlayerColor player)
    + void execute(pl.edu.go.game.Game game)
  }

  class AgreeCommand <<Command>> {
    - pl.edu.go.game.PlayerColor player
    + AgreeCommand(pl.edu.go.game.PlayerColor player)
    + void execute(pl.edu.go.game.Game game)
  }

  class ResumeCommand <<Command>> {
    - pl.edu.go.game.PlayerColor player
    + ResumeCommand(pl.edu.go.game.PlayerColor player)
    + void execute(pl.edu.go.game.Game game)
  }

  class TextCommandFactory <<Factory Method>> {
    + GameCommand fromNetworkMessage(String message, pl.edu.go.game.PlayerColor player)
  }
}

' =======================
'  pl.edu.go.server
' =======================
package "pl.edu.go.server" as server {

  class GameServer {
    + {static} void main(String[] args)
  }

  class ClientHandler <<Runnable>> {
    - java.net.Socket socket
    - GameSession session
    - pl.edu.go.game.PlayerColor color
    - java.io.PrintWriter out

    + ClientHandler(java.net.Socket socket, GameSession session, pl.edu.go.game.PlayerColor color)
    + pl.edu.go.game.PlayerColor getColor()
    + void sendLine(String line)
    + void run()
  }

  class GameSession <<Observer>> {
    - pl.edu.go.game.Game game
    - pl.edu.go.command.TextCommandFactory commandFactory
    - ClientHandler blackPlayer
    - ClientHandler whitePlayer

    + GameSession(pl.edu.go.game.Game game)
    + synchronized void setPlayer(pl.edu.go.game.PlayerColor color, ClientHandler handler)
    + synchronized void handleClientMessage(ClientHandler from, String message)
    + synchronized void startGame()
    ~ void broadcast(String line)

    + void onBoardChanged(pl.edu.go.board.Board board)
    + void onGameEnded(pl.edu.go.game.GameResult result)
    + void onPlayerToMoveChanged(pl.edu.go.game.PlayerColor player)
    ' (Jeśli masz onPhaseChanged, dopisz:)
    ' + void onPhaseChanged(pl.edu.go.game.GamePhase phase)

    - void sendScoreTerritoryAndDeadMask()
  }
}

' =======================
'  pl.edu.go.client.net
' =======================
package "pl.edu.go.client.net" as net {

  class NetworkClient {
    - java.net.Socket socket
    - java.io.BufferedReader in
    - java.io.PrintWriter out

    + void connect(String host, int port)
    + void disconnect()
    + boolean isConnected()
    + void sendLine(String line)

    + void setOnLine(java.util.function.Consumer<String> onLine)
    + void setOnError(java.util.function.Consumer<Throwable> onError)
  }
}

' =======================
'  pl.edu.go.client.gui
' =======================
package "pl.edu.go.client.gui" as gui {

  class GuiClientApp <<MVC:App>> {
    + void start(javafx.stage.Stage stage)
    + void stop()
    - void refreshUI()
  }

  class GameModel <<MVC:Model>> {
    - int boardSize
    - int[][] board
    - pl.edu.go.game.PlayerColor myColor
    - pl.edu.go.game.PlayerColor currentTurn
    - pl.edu.go.game.GamePhase phase
    - boolean finished
    - String endMessage
    - Integer scoreBlack
    - Integer scoreWhite
    - char[][] territoryMap
    - boolean[][] deadMask

    + void acceptServerLine(String line)
    + boolean canPlayNow()
    + boolean inReview()
    + boolean showScoringOverlays()
  }

  class BoardView <<MVC:View>> {
    + void redraw()
    + void setClickHandler(IntersectionClickHandler clickHandler)
  }

  class GameController <<MVC:Controller>> {
    + void onIntersectionClicked(int x, int y)
    + void sendPass()
    + void sendResign()
    + void sendAgree()
    + void sendResume()
  }
}

' =======================
'  pl.edu.go.client.cli
' =======================
package "pl.edu.go.client.cli" as cli {
  class CliClient {
    + {static} void main(String[] args)
  }
}

' =======================
'  pl.edu.go (root)
' =======================
package "pl.edu.go" as root {
  class MainTest {
    + {static} void main(String[] args)
  }
}

' =======================
'  RELACJE: board/model
' =======================
board.Board --> model.Stone : uses
board.Board --> model.StoneGroup : uses
model.StoneGroup o-- "0..*" model.Stone : contains
board.BoardFactory ..> board.Board : creates

' =======================
'  RELACJE: move
' =======================
move.MoveFactory ..> move.Move : creates
move.MoveAdapter ..> move.Move : adapts coords

' =======================
'  RELACJE: analysis
' =======================
analysis.PositionAnalyzer --> board.Board : reads
analysis.TerritoryAnalyzer --> board.Board : reads
analysis.ScoreCalculator ..> analysis.PositionAnalyzer : uses
analysis.ScoreCalculator ..> analysis.TerritoryAnalyzer : uses
analysis.ScoreCalculator --> board.Board : reads

' =======================
'  RELACJE: game
' =======================
game.Game --> board.Board : delegates rules
game.Game o-- "0..*" game.GameObserver : notifies
game.Game ..|> game.ObservableGame
game.PlayerColor ..> board.Board : maps Board.BLACK/WHITE

' =======================
'  RELACJE: command
' =======================
command.GameCommand <|.. command.PlaceStoneCommand
command.GameCommand <|.. command.PassCommand
command.GameCommand <|.. command.ResignCommand
command.GameCommand <|.. command.AgreeCommand
command.GameCommand <|.. command.ResumeCommand

command.TextCommandFactory ..> command.GameCommand : creates
command.TextCommandFactory ..> command.PlaceStoneCommand : creates
command.TextCommandFactory ..> command.PassCommand : creates
command.TextCommandFactory ..> command.ResignCommand : creates
command.TextCommandFactory ..> command.AgreeCommand : creates
command.TextCommandFactory ..> command.ResumeCommand : creates

command.PlaceStoneCommand --> game.Game : execute()
command.PassCommand --> game.Game : execute()
command.ResignCommand --> game.Game : execute()
command.AgreeCommand --> game.Game : execute()
command.ResumeCommand --> game.Game : execute()

' =======================
'  RELACJE: server
' =======================
server.GameSession ..|> game.GameObserver
server.GameSession --> game.Game : owns
server.GameSession --> command.TextCommandFactory : uses
server.GameSession --> server.ClientHandler : holds players

server.GameSession ..> analysis.ScoreCalculator : uses (scoring)
server.GameSession ..> analysis.TerritoryAnalyzer : uses (map)
server.GameSession ..> analysis.PositionAnalyzer : uses (dead stones)

server.ClientHandler --> server.GameSession : forwards messages
server.ClientHandler --> game.PlayerColor : assigned color

server.GameServer ..> board.BoardFactory : creates board
server.GameServer ..> game.Game : creates
server.GameServer ..> server.GameSession : creates
server.GameServer ..> server.ClientHandler : creates + threads
server.GameServer ..> java.net.ServerSocket : opens port

' =======================
'  RELACJE: GUI (MVC)
' =======================
gui.GuiClientApp --> net.NetworkClient : owns
gui.GuiClientApp --> gui.GameModel : owns
gui.GuiClientApp --> gui.GameController : owns
gui.GuiClientApp --> gui.BoardView : owns

gui.GameController --> net.NetworkClient : sends commands
gui.GameController --> gui.GameModel : checks state

gui.BoardView --> gui.GameModel : renders state
gui.GameModel ..> game.PlayerColor : stores
gui.GameModel ..> game.GamePhase : stores

@enduml
